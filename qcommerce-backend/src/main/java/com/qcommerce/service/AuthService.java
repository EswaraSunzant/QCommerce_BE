package com.qcommerce.service;

import com.qcommerce.generated.model.AuthResponse;
import com.qcommerce.generated.model.UserRegistration;
import com.qcommerce.generated.model.RoleReference;
import com.qcommerce.model.UserEntity;
import com.qcommerce.model.RoleEntity;
import com.qcommerce.repository.UserRepository;
import com.qcommerce.repository.RoleRepository;

import com.qcommerce.exception.InvalidInputException;
import com.qcommerce.exception.UserAlreadyExistsException;

import org.openapitools.jackson.nullable.JsonNullable;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.HashSet;
import java.util.List; // Import List
import java.util.Optional;
import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;

@Service
public class AuthService {

    private final UserRepository userRepository; 
    private final RoleRepository roleRepository; 
    private final PasswordEncoder passwordEncoder;

    public AuthService(UserRepository userRepository, RoleRepository roleRepository, PasswordEncoder passwordEncoder) {
        this.userRepository = userRepository;
        this.roleRepository = roleRepository;
        this.passwordEncoder = passwordEncoder;
    }

    @Transactional
    public AuthResponse registerUser(UserRegistration registration) {
        if (userRepository.findByEmail(registration.getEmail().toLowerCase()).isPresent()) {
            throw new UserAlreadyExistsException("User with email " + registration.getEmail() + " already exists.");
        }

        UserEntity newUserEntity = new UserEntity();
        newUserEntity.setEmail(registration.getEmail().toLowerCase());
        if (registration.getPhone().isPresent()) {
             newUserEntity.setPhone(registration.getPhone().get());
        }
        newUserEntity.setPasswordHash(passwordEncoder.encode(registration.getPassword())); // Use passwordHash
        newUserEntity.setActive(true); // Set new users as active by default

        if (registration.getLocale().isPresent() && registration.getLocale().get() != null) {
            // Assuming the generated enum has a getValue() or similar method to get the string representation
            // Or, if it's a simple enum, .name() or .toString() might work.
            // For enums generated by openapi-generator, it's often .getValue()
            newUserEntity.setLocale(registration.getLocale().get().getValue());
        }
        
        Set<RoleEntity> assignedRoles = new HashSet<>();
        // Correctly handle JsonNullable for roles
        if (registration.getRoles().isPresent() && registration.getRoles().get() != null && !registration.getRoles().get().isEmpty()) {
            List<RoleReference> roleReferences = registration.getRoles().get();
            for (RoleReference roleRef : roleReferences) {
                if (roleRef.getId() == null) {
                    throw new InvalidInputException("Role ID cannot be null.", "roles[" + roleReferences.indexOf(roleRef) + "].id");
                }
                // RoleReference.id is Integer (or Long if format: int64 was effective), RoleEntity.id is Long
                RoleEntity role = roleRepository.findById(roleRef.getId()) // Assuming RoleReference.id is already Long due to format: int64
                    .orElseThrow(() -> new InvalidInputException("Invalid role ID: " + roleRef.getId(),
                                                                "roles[" + roleReferences.indexOf(roleRef) + "].id"));
                assignedRoles.add(role);
            }
        } else {
            // Optional: Assign a default role if no roles are provided
            // RoleEntity defaultUserRole = roleRepository.findByName("ROLE_USER")
            // .orElseThrow(() -> new RuntimeException("Default role ROLE_USER not found. Please configure roles."));
            // assignedRoles.add(defaultUserRole);
        }
        newUserEntity.setRoles(assignedRoles);

        UserEntity savedUserEntity = userRepository.save(newUserEntity);

        com.qcommerce.generated.model.User responseUser = new com.qcommerce.generated.model.User();
        responseUser.setId(savedUserEntity.getId()); // Corrected: Pass Long directly
        responseUser.setEmail(savedUserEntity.getEmail());
        if (savedUserEntity.getPhone() != null) {
            responseUser.setPhone(JsonNullable.of(savedUserEntity.getPhone()));
        }
        if (savedUserEntity.getLocale() != null) {
            responseUser.setLocale(JsonNullable.of(savedUserEntity.getLocale()));
        }
        responseUser.setIsActive(savedUserEntity.isActive()); // Map isActive
        
        if (savedUserEntity.getRoles() != null) {
            responseUser.setRoles(JsonNullable.of(
                savedUserEntity.getRoles().stream().map(roleEntity -> {
                    com.qcommerce.generated.model.Role role = new com.qcommerce.generated.model.Role();
                    role.setId(roleEntity.getId()); // Corrected: Pass Long directly
                    role.setName(roleEntity.getName());
                    return role;
                }).collect(Collectors.toList())
            ));
        }

        String accessToken = "dummy-access-token-" + UUID.randomUUID().toString();
        String refreshToken = "dummy-refresh-token-" + UUID.randomUUID().toString();

        AuthResponse authResponse = new AuthResponse();
        authResponse.setAccessToken(accessToken);
        authResponse.setRefreshToken(JsonNullable.of(refreshToken));
        authResponse.setUser(responseUser);

        return authResponse;
    }

    public Optional<RoleEntity> findRoleById(Long id) { 
        return roleRepository.findById(id);
    }
}